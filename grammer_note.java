
 // 과제를 할 땐 비록 블록처리가 되어있지만 들여쓰기 잘 써주고 주석을 항상 같이 써줘라!!

public class grammer_note { 
	
	// 그한 파일안에 public class ~가 두번올수 없다. 
	// 그냥 class ~로 밑에 새로 꾸려나가는 건 된다. 그러나 굳이 클래스를 만들거나면 새 파일에 만드는게좋지
	// 클래스가 두 개 있는 상태로 저장시켜면 src에는 하나로! 클래스는 bin 폴더에 구분되서! 저장된다. (src 폴더 : java, bin 폴더 : class)
	public static int sum(int n, int m) { 
		// sum 메소드
		return n + m;
	}
	
	public static void main(String[] args) {
		int i = 20;
		int s = sum(i,10); // sum()메소드 호출
		System.out.println(s); // 정수 s 값 화면 출력
		/* 그냥 print()문은 \n을 제공하지 않는다 (장문 주석문) */
		
/**
  이런걸 자바독이라는 실행파일이 문서화를 할때 자동으로 추출해주는 부분. 포맷팅까지해서..
  클래스나 메소드 앞에 붙여가지고 걔들이 어떤 용도로 만들어졌는지 개발자들이 알려주거나... 코드위에 /** 치고 엔터누르면 기본설명 자동완성. 거기에 내가 덧붙여 설명하면되.
  */

// 자바는 변수선언시 항상 초기화[할당해주고 초기값 지정까지].. chat c1 = 'a'
// 초기값을 제대로 안주고 동작하게하면 그 초기값은 현재 메모리에 들어있는 가비지값이 사용되게되서 결과가 일관되게 나오지 않을 수 있다.
// 위의 system코드에 글자를 찍고 f3누르니까 java 설치파일에 들어가있던 system.class 파일이 호출되네 ㄷㄷ.. 소스가 열리지않고 컴파일 된 구조의 자료들이 나오는거지.. class 니까..
// goto 는 예약어도 아니고 변수명으로도 못 써. 자바가 시러하나봐~
		
		
// system.out.println의 .은 다 소속의 개념으로 접근한다.. 
// system이라는 클래스의 일환으로 out변수(in이나 err도 있음)가 있고 사실 printstream이라는 타입의 클래스 형태인 셈이지..
// 자바에서 미리만들어놓은. 다양한 인자들을 받을 수 있도록 println(많은 경우의 수)을 많이 만들어놨네
// 이래서 기본데이터타입을 제외한 모든 것이 객체! Everything is object
// 자바는 객체지향이다라는 개념을 약간은 벗어나는것이 기본타입 8개를 들 수 있는거지.. 얘네 빼고 나머지는 다 객체.. 쟤네들까지 클래스로 짠 예시물이 너무 속도가 느리게 동작했기때문ㅇ.
// 객체로 저장하지말고 값만 기본으로 저장하는 방식을 선택. 그래서 총 기본 데이터 타입과 객체타입으로 나눌수있겠지


// long j = 3이라하면 3 먼저보고 작은공간을 할당했다가 long이네 하고 다시 큰 공간에 저장하기 때문에 두번일한다.. 그래서 long j =3L 로 써주면 스무스 
// 12. 이나 .1234 같이 절대!!! 힘들게 알아보게 쓰지마라 의도를 명확하게 항상표기.
// 파이썬과 다르게 True대신 true, none 대신 null 인듯. 얘도 string s = null 이런식으로 초기화해주고 밑에서 써야 에러가 안나네
// var는 굳이 쓰지마라. 
// ("원의 면적" + cia) 이런식으로 쓰면 앞에 " " 가 있기때문에 하나의 문자열로 읽어준다. 
// int y = (int) 3.0; 으로 강제 형변환 .. 커지는 것은 알아서 해주고
// 우선순위에 안끌려다니게 그냥 애초에 ()를 잘 이용하라!
// if else문은 길어질수록 구조화 되지않는 문법!. 차라리 switch를 써야된데!.

//파이썬에서는 a=3,b=2,c=5 이런거 안됐자나
// 자바에서는 int a=2, b=2, c=3 쌉가능
// 변수 잡고 refactor-rename 하면 변수이름 일괄변경가능 
		
// 이렇게 크게 3가지 형태.. [10]은 첫번째 경우만인거 꼭 확인
//		int[] i = new int[10]
//		int[] i = {0,1,2,3,4,5,6}
//		int[] i = new int[] {0,1,2,3,4,5,6}
		
// 에러잡기
int subbm = 2;
try {
	float ex = subbm / 2;
} catch(Exception e) {
	System.out.println("Again");
	e.printStackTrace(); // 에러 무슨에런지 다 보여주고 잡는 씹사기 코드 
}

// 복습했던거 대충 정리해보면 
// 패키지까지 영향을 미치는 요인은 접근지정자에 달렸다고보면 될거같고, 생략시 default가 되기때문에 다른패키지에 상속시킨다면 public을 써라
// public을 통해서 데이터 멤버들의 값을 상속시킬수 있고 자식에서는 오버라이딩을 통해 멤버값을 변화시킬 수 있다.
// 데이터 멤버의 오버라이딩과 메소드 멤버의 오버라이딩이 있네.. 그런데 다른 곳에서 자식클래스를 쓸려니까 메소드멤버는 바뀐거주고 데이터멤버는 부모꺼주내
// static만 쓰면 같은 클래스 내의 main에 영향을 미치면 된다고 일단 생각하고, 얘는 접근지정자와 함께 쓰기 때문에 깊게 생각 X

	}
}




